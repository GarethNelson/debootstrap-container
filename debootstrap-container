#!/bin/bash
#
# wrapper for debootstrap fakechroot fakeroot to easily generate persistent debiancontainers
# for installing/running applications/packages *outside* the real host.
# This is definately not secure or as cool as docker, but it is a nice way to deploy
# applications on a openvz container (which doesnt run docker).
#
# more info: http://coderofsalvation.github.io/debootstrap-container
set -e; # halt on error

requirements=(fakechroot fakeroot)
image="wheezy"
group=users
backupdirs="srv etc opt"
containerpath="/srv/containers"

genimage(){ 
  {
    echo -e "about to generate minbase debian filesystem\n\nfirst time will take a while..\n"; sleep 1s; 
    which debootstrap &>/dev/null || { echo "please install the 'debootstrap' packages (debian hint: apt-get install debootstrap)"; exit 1; }
    debootstrap --variant=minbase $image $containerpath/minbase || { echo "something went wrong :("; return 1; }
    patch "$containerpath/minbase"
  } | prettyprint
}

patch(){
  dir="$1"; name="$2"
  [[ ${#dir} == 0 ]] && { echo "wrong dir: $dir"; exit 1;}
  echo "patching + stripping"
  rm $dir/var/cache/apt/archives/*
  rm $dir/var/{run,lock} && mkdir $dir/var/{run,lock};                # needed in order to run applications 
  rm $dir/lib/x86_64-linux-gnu/libc.so.6;                           # not sure why but I had cases
  rm -rf $dir/root/.*
  ln -s /lib/x86_64-linux-gnu/libc.so.6 $dir/lib/x86_64-linux-gnu/. # where I could only chroot succesfully by doing so
  chmod -R u+rwX "$dir/var"
  chmod -R g-w "$dir"
  chmod go-w $dir
}

# adds container to filesystem
add(){
  [[ ! -n "$1" ]] && { echo "usage: $0 add <containername> [containerpath] [distroname]"; return 1; }
  {
    name="$1"; [[ -n "$2" ]] && containerpath="$2"; [[ -n "$3" ]] && image="$3"
    [[ ! -d $containerpath ]] && mkdir $containerpath
    [[ ! -d $containerpath/minbase ]] && genimage
    [[ -d $containerpath/$name ]] && { echo "$containerpath/$name already exists..exiting"; exit 1; }
    [[ ! -d $containerpath/minbase ]] && { echo "could not find $containerpath/minbase, debootstrap failed earlier probably"; exit 1; }
    cp -r $containerpath/minbase $containerpath/$name
    echo -e '# do not edit\n# debootstrap-container will generate apt-get commands here' > $containerpath/$name/install.packages
    read -p "enter user which should be 'root'? " user
    [[ ! -d /home/$user ]] && { echo "could not find /home/$user dir..aborting"; exit 1; }
    chown -R $user:$group "$containerpath/$name"*
    adduser $user "$name"
    fakechroot fakeroot chroot $containerpath/$name dpkg --get-selections > $containerpath/$name/var/packages.minbase.txt # remember packages
    echo -e '/install.packages\n# put your own automation scripts below\n# they will get triggered upon debootstrap-container import\n' > $containerpath/$name/install
    chmod 770 $containerpath/$name/install
    echo "created container '$containerpath/$name'"
  } | prettyprint
}

# adds user and gives (fake) root ssh access to container
adduser(){
  user="$1"; name="$2"
  mount --bind /home/$user $containerpath/$name/root
  read -p "redirect user into container upon ssh-login? (y/n) " add; 
  if [[ "$add" == "y" ]]; then 
    echo -e "fakechroot fakeroot chroot $containerpath/$name /bin/bash\nexit" > /home/$user/.profile
    echo -e "export HOME=/root\nexport PS1='root@$name# '\nPROMPT_COMMAND='echo -ne \""'\033]0;${USER}@${HOSTNAME}: $name\007'"\";PS1=\"\$PS1\"'" >  $containerpath/$name/.bashrc
    chown root:root $containerpath/$name/.bashrc /home/$user/.profile
    chmod 700 $containerpath/$name/.bashrc 
    chmod 744 /home/$user/.profile;
  fi
}

check(){
  {
    OK=0
    for i in "${requirements[@]}"; do 
      which $i &>/dev/null || {
        read -p "$i is not installed..apt-get now? (y/n) " answer
        [[ "$answer" == "y" ]] && sudo apt-get -y install $i || OK=1
      }
    done
    return $OK
  } | prettyprint
}

export(){
  [[ ! -n "$1" ]] && { echo "usage: $0 export <containerdir> [outfile]"; return 1; }
  {
    dir="$1"; [[ -n "$2" ]] && outfile="$2" || outfile="/tmp/$(basename "$dir").tar.gz"
    [[ ! -d "$dir" ]] && { echo "container $dir does not exist"; exit 1; }
    echo "analyzing additional installed packages + backing up dirs: $backupdirs"
    fakechroot fakeroot chroot "$dir" dpkg --get-selections > $dir/var/packages.txt # dump packages
    fakechroot fakeroot chroot "$dir" sort /srv/packages.txt /var/packages.minbase.txt | uniq --unique | sed 's/\t.*//g;s/^/apt-get -y install --force-yes /g'> $dir/install.packages
    chmod 755 $dir/srv/install*
    cd $dir; tar cpjf "$outfile" ${backupdirs}
    echo "written $outfile"
  } | prettyprint
}

import(){
  [[ ! -n "$1" ]] && { echo "usage: $0 import <containername> <tarball>"; return 1; }
  dir="$1"; targz="$2"
  {
    [[ ! -d "$dir" ]] && { echo "creating new container"; add $(basename $dir); }
    [[ ! -d "$dir/usr" ]] && { echo "container $dir is not a container"; exit 1; }
    echo "importing new installed packages + importing dirs: $backupdirs"
    cd "$dir" && for bdir in $backupdirs;  do rm -rf $bdir; done
    tar vxpjf $targz | while read line; do tput el; printf "\r[x] unpacking: $line"; done; echo ""
    fakechroot fakeroot chroot "$dir" bash /install.packages  # install packages
    fakechroot fakeroot chroot "$dir" bash /install           # install packages
    echo "done" 
  } | prettyprint
}

run(){
  [[ "$(whoami)" == root ]] && { echo "please do not run container as root"; exit 1; }
  [[ ! -n "$1" ]] && { echo "usage: $0 run <containerdir>"; return 1; } 
  fakechroot fakeroot chroot "$1" /bin/bash /boot.container
}

prettyprint(){ 
  cat - | while read line; do echo "[x] $line"; done;
}

check && [[ -n "$1" ]] && { "$@"; } || { add; run; import; export; }
